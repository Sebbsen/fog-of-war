require "assets.terrain_placer"
require "assets.player_bricks"

-- Wir definieren die Größe
local GRID_WIDTH = 10
local GRID_HEIGHT = 10

local TILESETS_KEY = {
	[0] = "village",
	[4] = "mountain",
	[1] = "forest",
	[3] = "medow",
	[2] = "pond",
	[10] = "dragon"
}

local TILESETS = {
	["forest"] = {
		["start"] = 1,
		["end"] = 3 
	},
	["mountain"] = {
		["start"] = 11,
		["end"] = 13 
	},
	["medow"] = {
		["start"] = 21,
		["end"] = 25 
	},
	["pond"] = {
		["start"] = 31,
		["end"] = 33 
	},
	["fog"] = {
		["start"] = 101,
		["end"] = 200 
	},
	["village"] = {
		["start"] = 61,
		["end"] = 63 
	},
	["dragon"] = {
		["forest"] = 51,
		["mountain"] = 52,
		["medow"] = 53,
		["pond"] = 54
	}
}

local TILE_SIZE = 64

local BRICK_SIZE = 3
local BRICKS = {
	["L"] = {
		{0, 1, 0},
		{0, 1, 0},
		{0, 1, 1}
	},
	["J"] = {
		{0, 1, 0},
		{0, 1, 0},
		{1, 1, 0}
	},
	["T"] = {
		{0, 0, 0},
		{1, 1, 1},
		{0, 1, 0}
	}
}
local CURRENT_BRICK = get_next_brick()

--- --- CREATE MATRIX SECTION --- ---

-- Das ist unsere Matrix (Zahlen-Tabelle)
local function create_ground_matrix()
	local m = {}
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			m[y][x] = math.random(1, 4) 
		end
	end
	return m
end

local function permutateX(x)
	local a = {}
	-- füllen: Lua-Arrays sind 1-basiert.
	for i = 1, x do
		a[i] = i - 1
	end

	-- Fisher–Yates Shuffle
	for i = x, 2, -1 do
		local j = math.random(i) -- 1..i
		a[i], a[j] = a[j], a[i]
	end

	return a
end

-- Dragons zufällig verteilen
local function create_dragon_matrix(grid)
	local dragons = 0
	local a = permutateX(GRID_HEIGHT * GRID_WIDTH)
	local m = {}
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			m[y][x] = 0
		end
	end
	for z = 1, GRID_HEIGHT * GRID_WIDTH do
		local j = math.floor(a[z] / GRID_WIDTH) + 1
		local i = a[z] % GRID_HEIGHT + 1
		if grid[j][i] > 0 then
			m[j][i] = 1
			dragons = dragons + 1
			if dragons >= 4 then
				break
			end
		end
	end
	return m
end

local function create_fog_matrix()
	local tile_start = TILESETS["fog"]["start"]
	local m = {}
	local i = 0
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			m[y][x] = tile_start+i
			i = i+1
		end
	end
	return m
end

local function create_last_placement_matrix()
	local m = {}
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			m[y][x] = 0
		end
	end
	return m
end
	

function init(self)
	-- 1. Matrix generieren
	-- self.ground_matrix = create_ground_matrix()
	self.ground_matrix = get_grid()
	self.dragon_matrix = create_dragon_matrix(self.ground_matrix)
	self.fog_matrix = create_fog_matrix()
	self.last_placement_matrix = create_last_placement_matrix()

	msg.post(".", "acquire_input_focus")
	
	draw_tilemap(self, true, true)
end

function getRandomGroundTileOfType(tile_type) 
	-- 1 ist forest 2 ist mountain, 3 ist medow, 4 ist pound
	-- ich will die Zahl 1,2,3,4 dann dazu ein random tile dieser art zurückgeben
	-- mit dem medow.start und medow.end etc

	-- Hole den Namen basierend auf dem Typ (z.B. "forest")
	local set_name = TILESETS_KEY[tile_type]

	-- Sicherheitshalber prüfen, ob der Typ existiert
	if set_name and TILESETS[set_name] then
		local set = TILESETS[set_name]
		-- Gibt eine Zufallszahl zwischen dem Start- und End-Tile zurück
		return math.random(set["start"], set["end"])
	end

	-- Fallback: Falls etwas schief geht, gib Tile 0 oder 1 zurück
	return 1
end

function draw_tilemap(self, draw_ground, draw_dragons)
	print("draw")
	-- 2. Pfad zur Tilemap-Komponente definieren
	-- "#level" ist die ID der Tilemap-Komponente im Game Object
	local tilemap_url = "#level" 

	local north = {}
	local west = {}
	for i = 1, GRID_WIDTH do
		north[i] = false
	end
	for j = 1, GRID_HEIGHT do
		west[j] = false
	end
		
	-- 3. Die Matrix auf die Tilemap zeichnen
	for y = 1, GRID_HEIGHT do
		for x = 1, GRID_WIDTH do
			local ground_tile_to_draw = getRandomGroundTileOfType(self.ground_matrix[y][x])
			local fog_tile_to_draw = self.fog_matrix[y][x]
			local last_placement_tile_to_draw = self.last_placement_matrix[y][x]
			-- invertieren, damit das erste Tile oben links ist
			local inverted_y = (GRID_HEIGHT + 1) - y

			-- Syntax: tilemap.set_tile(url, layer_name, x, y, tile_id)
			if draw_ground then
				tilemap.set_tile(tilemap_url, "ground", x, inverted_y, ground_tile_to_draw)
			end
			if draw_dragons and self.dragon_matrix[y][x] == 1 then
				print(TILESETS_KEY[1])
				local terrain_name = TILESETS_KEY[self.ground_matrix[y][x]]
--				if terrain_name <> TILESETS_KEY[0] then
				tilemap.set_tile(tilemap_url, "dragons", x, inverted_y, TILESETS["dragon"][terrain_name])
				north[x] = true
				west[y] = true
			end
			tilemap.set_tile(tilemap_url, "fog", x, inverted_y, fog_tile_to_draw)
			tilemap.set_tile(tilemap_url, "lastplacement", x, inverted_y, last_placement_tile_to_draw)
		end
	end
	-- Ränder aufbauen
	if draw_dragons then
		for i = 1, GRID_WIDTH do
			if north[i] == true then
				local position = vmath.vector3(32+i*64, 16+11*64, 0.7)
				local id = factory.create("factory_north#factory", position)
			end
		end
		for j = 1, GRID_HEIGHT do
			if west[j] == true then
				local position = vmath.vector3(48, 32+(GRID_HEIGHT + 1 - j)*64, 0.7)
				local id = factory.create("factory_west#factory", position)
			end
		end
	end	
end

function reset_draw_brick_preview()
	local tilemap_url = "#level"
	for y = 1, GRID_HEIGHT do
		for x = 1, GRID_WIDTH do
			tilemap.set_tile(tilemap_url, "preview", x, y, 0)
		end
	end
end
	

local function draw_brick_preview(self, grid_x, grid_y, is_visible)
	local tilemap_url = "#level"
	local selected_brick = CURRENT_BRICK

	reset_draw_brick_preview()

	for y = 1, BRICK_SIZE do
		for x = 1, BRICK_SIZE do
			if selected_brick[y][x] == 1 then
				local target_x = x + grid_x - 2
				local target_y = (GRID_HEIGHT + 1) - (y + grid_y - 2)

				-- Prüfen, ob wir innerhalb der Map-Grenzen sind
				if target_x >= 1 and target_x <= GRID_WIDTH and target_y >= 1 and target_y <= GRID_HEIGHT then
					if is_visible then
						tilemap.set_tile(tilemap_url, "preview", target_x, target_y, 42)
						if not legalBrickPlacement(self, grid_x, grid_y) then
							tilemap.set_tile(tilemap_url, "preview", target_x, target_y, 41)
						end
					else
						-- Stelle den Originalzustand aus der Matrix wieder her
						-- local original_y = (GRID_HEIGHT + 1) - target_y
						-- tilemap.set_tile(tilemap_url, "preview", target_x, target_y, self.fog_matrix[original_y][target_x])
					end
				end
			end
		end
	end
end

local function reset_last_placement_matrix(self) 
	self.last_placement_matrix = create_last_placement_matrix()
end

function legalBrickPlacement(self, grid_x, grid_y)
	return isAdjacentToLastPlaced(self, grid_x, grid_y) and noOverlapToPast(self, grid_x, grid_y) and notOutOfMap(self, grid_x, grid_y)
end

function isAdjacentToLastPlaced(self, grid_x, grid_y)
	local selected_brick = CURRENT_BRICK 

	-- 1. PRÜFUNG: Ist es der allererste Zug?
	-- Wir scannen die Matrix, ob sie komplett leer (0) ist.
	local is_first_move = true
	for y = 1, GRID_HEIGHT do
		for x = 1, GRID_WIDTH do
			if self.last_placement_matrix[y][x] ~= 0 then
				is_first_move = false
				break
			end
		end
		if not is_first_move then break end
	end

	-- Wenn noch nie etwas gelegt wurde, ist jeder Ort erlaubt
	if is_first_move then 
		return true 
	end

	-- 2. PRÜFUNG: Nachbarschaft
	-- Wir gehen durch jeden Block des neuen Steins (3x3 Grid)
	for y = 1, BRICK_SIZE do
		for x = 1, BRICK_SIZE do
			if selected_brick[y][x] == 1 then
				-- Berechne die Position im echten Grid
				local target_y = y + grid_y - 2
				local target_x = x + grid_x - 2

				-- Die 4 Nachbarn (Oben, Unten, Links, Rechts)
				local neighbors = {
					{x = 0, y = 1}, 
					{x = 0, y = -1},
					{x = 1, y = 0}, 
					{x = -1, y = 0}
				}

				for _, offset in ipairs(neighbors) do
					local check_x = target_x + offset.x
					local check_y = target_y + offset.y

					-- Boundary Check: Nicht außerhalb des Arrays lesen
					if check_x >= 1 and check_x <= GRID_WIDTH and check_y >= 1 and check_y <= GRID_HEIGHT then
						-- Wenn hier ein Tile vom letzten Zug liegt (ungleich 0)
						if self.last_placement_matrix[check_y][check_x] ~= 0 then
							return true -- Verbindung gefunden!
						end
					end
				end
			end
		end
	end

	-- Keine Verbindung gefunden
	return false
end

function noOverlapToPast(self, grid_x, grid_y)
	local selected_brick = CURRENT_BRICK 

	for y = 1, BRICK_SIZE do
		for x = 1, BRICK_SIZE do
			if selected_brick[y][x] == 1 then
				-- Berechne die absolute Position im Grid
				local target_y = y + grid_y - 2
				local target_x = x + grid_x - 2

				-- Sicherheits-Check: Sind wir innerhalb des Grids?
				if target_y >= 1 and target_y <= GRID_HEIGHT and target_x >= 1 and target_x <= GRID_WIDTH then

					-- DER CHECK:
					-- Wenn in der fog_matrix eine 0 steht, wurde hier schon gebaut.
					-- Das bedeutet Überlappung -> Funktion gibt false zurück.
					if self.fog_matrix[target_y][target_x] == 0 then
						return false 
					end
				end
			end
		end
	end

	-- Wenn die Schleife durchläuft, ohne dass wir eine 0 gefunden haben:
	return true
end


function notOutOfMap(self, grid_x, grid_y)
	local selected_brick = CURRENT_BRICK
	for y = 1, BRICK_SIZE do
		for x = 1, BRICK_SIZE do
			if selected_brick[y][x] == 1 then
				-- Berechne die absolute Position im Grid
				local target_y = y + grid_y - 2
				local target_x = x + grid_x - 2

				-- Check: Sind wir innerhalb des Grids?
				if target_y >= 1 and target_y <= GRID_HEIGHT and target_x >= 1 and target_x <= GRID_WIDTH then
					
				else
					return false
				end
			end
		end
	end
	return true
end



function on_input(self, action_id, action)
	-- 2. HOVER EFFEKT (Muss außerhalb von action_id == hash("touch") sein!)
	if action.x and action.y then
		local mouse_x = math.floor(action.x / TILE_SIZE) + 1
		local mouse_y = math.floor(action.y / TILE_SIZE) + 1
		local mouse_y_inverted = (GRID_HEIGHT + 1) - mouse_y
		-- Nur aktualisieren, wenn die Maus das Feld gewechselt hat
		if mouse_x ~= self.last_mouse_x or mouse_y_inverted ~= self.last_mouse_y then
			-- Alte Vorschau an der alten Position löschen
			if self.last_mouse_x then
				draw_brick_preview(self, self.last_mouse_x, self.last_mouse_y, false)
			end

			-- Neue Vorschau an der aktuellen Position zeichnen
			draw_brick_preview(self, mouse_x, mouse_y_inverted, true)

			self.last_mouse_x = mouse_x
			self.last_mouse_y = mouse_y_inverted
		end
	end
	
	-- 3. KLICK (Platzieren)
	if action_id == hash("touch") and action.pressed then
		local mouse_x = math.floor(action.x / TILE_SIZE) + 1
		local mouse_y = math.floor(action.y / TILE_SIZE) + 1
		local mouse_y_inverted = (GRID_HEIGHT + 1) - mouse_y
		if not legalBrickPlacement(self, mouse_x, mouse_y_inverted) then
			return
		end
		print("klick")
		reset_last_placement_matrix(self)
		local selected_brick = CURRENT_BRICK

		for y = 1, BRICK_SIZE do
			for x = 1, BRICK_SIZE do
				if selected_brick[y][x] == 1 then
					local target_y = y + mouse_y_inverted - 2
					local target_x = x + mouse_x - 2

					-- Sicherheits-Check, damit wir nicht außerhalb der Matrix schreiben
					if target_y >= 1 and target_y <= GRID_HEIGHT and target_x >= 1 and target_x <= GRID_WIDTH then
						self.fog_matrix[target_y][target_x] = 0
						self.last_placement_matrix[target_y][target_x] = 43
						if self.dragon_matrix[target_y][target_x] == 1 then
							sound.play("/background#dragon")
						end
					end
				end
			end
		end
		-- Map neu zeichnen (ohne Ground, um Performance zu sparen)
		draw_tilemap(self, false, false)
		CURRENT_BRICK = get_next_brick()
		
		local points = 0
		for y = 1, GRID_HEIGHT do
			for x = 1, GRID_WIDTH do
				if self.fog_matrix[y][x] == 0 then 
					if self.ground_matrix[y][x] == 3 then -- teich Z
						points = points + 10
					elseif self.ground_matrix[y][x] == 2 then -- wiese J
						points = points + 15
					elseif self.ground_matrix[y][x] == 1 then -- wald L
						points = points + 20
					elseif self.ground_matrix[y][x] == 4 then -- berge T
						points = points + 25
					end

					if self.dragon_matrix[y][x] == 1 then
						points = points - 100
					end
				end
			end
		end
		print(points)
		msg.post("main:/gui#game", "current_score", { score = points })
		sound.play("/background#scribble")
		
	end
end