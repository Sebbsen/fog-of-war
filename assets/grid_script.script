require "assets.terrain_placer"
-- Wir definieren die Größe
local GRID_WIDTH = 10
local GRID_HEIGHT = 10

local TILESETS_KEY = {
	[0] = "medow",
	[1] = "forest",
	[2] = "mountain",
	[3] = "village",
	[4] = "pond"
}

local TILESETS = {
	["forest"] = {
		["start"] = 1,
		["end"] = 3 
	},
	["mountain"] = {
		["start"] = 11,
		["end"] = 13 
	},
	["medow"] = {
		["start"] = 21,
		["end"] = 25 
	},
	["pond"] = {
		["start"] = 31,
		["end"] = 33 
	},
	["fog"] = {
		["start"] = 101,
		["end"] = 200 
	},
	["village"] = {
		["start"] = 61,
		["end"] = 63 
	}
}

local TILE_SIZE = 64

local BRICK_SIZE = 3
local BRICKS = {
	["L"] = {
		{0, 1, 0},
		{0, 1, 0},
		{0, 1, 1}
	},
	["J"] = {
		{0, 1, 0},
		{0, 1, 0},
		{1, 1, 0}
	},
	["T"] = {
		{0, 0, 0},
		{1, 1, 1},
		{0, 1, 0}
	}
}
local CURRENT_BRICK = BRICKS["T"]


-- Das ist unsere Matrix (Zahlen-Tabelle)
local function create_ground_matrix()
	local m = {}
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			-- Wir füllen alles mit der 1 (dein erstes Tile in der Tilesource)
			-- Wenn du ein Schachbrettmuster willst: ((x + y) % 2 == 0) ? 1 : 2
			m[y][x] = math.random(1, 4) 
		end
	end
	return m
end

local function create_fog_matrix()
	local tile_start = TILESETS["fog"]["start"]
	local m = {}
	local i = 0
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			-- Wir füllen alles mit der 1 (dein erstes Tile in der Tilesource)
			-- Wenn du ein Schachbrettmuster willst: ((x + y) % 2 == 0) ? 1 : 2
			m[y][x] = tile_start+i
			i = i+1
		end
	end
	return m
end
	

function init(self)
	-- 1. Matrix generieren
	-- self.ground_matrix = create_ground_matrix()
	self.ground_matrix = get_grid()
	self.fog_matrix = create_fog_matrix()

	msg.post(".", "acquire_input_focus")
	
	draw_tilemap(self, true)
end

function getRandomGroundTileOfType(tile_type) 
	-- 1 ist forest 2 ist mountain, 3 ist medow, 4 ist pound
	-- ich will die Zahl 1,2,3,4 dann dazu ein random tile dieser art zurückgeben
	-- mit dem medow.start und medow.end etc

	-- Hole den Namen basierend auf dem Typ (z.B. "forest")
	local set_name = TILESETS_KEY[tile_type]

	-- Sicherheitshalber prüfen, ob der Typ existiert
	if set_name and TILESETS[set_name] then
		local set = TILESETS[set_name]
		-- Gibt eine Zufallszahl zwischen dem Start- und End-Tile zurück
		return math.random(set["start"], set["end"])
	end

	-- Fallback: Falls etwas schief geht, gib Tile 0 oder 1 zurück
	return 1
end

function draw_tilemap(self, draw_ground)
	print("draw")
	-- 2. Pfad zur Tilemap-Komponente definieren
	-- "#level" ist die ID der Tilemap-Komponente im Game Object
	local tilemap_url = "#level" 

	-- 3. Die Matrix auf die Tilemap zeichnen
	for y = 1, GRID_HEIGHT do
		for x = 1, GRID_WIDTH do
			local ground_tile_to_draw = getRandomGroundTileOfType(self.ground_matrix[y][x])
			local fog_tile_to_draw = self.fog_matrix[y][x]
			-- invertieren, damit das erste Tile oben links ist
			local inverted_y = (GRID_HEIGHT + 1) - y

			-- Syntax: tilemap.set_tile(url, layer_name, x, y, tile_id)
			if draw_ground then
				tilemap.set_tile(tilemap_url, "ground", x, inverted_y, ground_tile_to_draw)
			end
			tilemap.set_tile(tilemap_url, "fog", x, inverted_y, fog_tile_to_draw)
		end
	end
end

local function draw_brick_preview(self, grid_x, grid_y, is_visible)
	local tilemap_url = "#level"
	local selected_brick = BRICKS["T"] -- Später durch self.current_brick ersetzbar

	for y = 1, BRICK_SIZE do
		for x = 1, BRICK_SIZE do
			if selected_brick[y][x] == 1 then
				local target_x = x + grid_x - 2
				local target_y = (GRID_HEIGHT + 1) - (y + grid_y - 2)

				-- Prüfen, ob wir innerhalb der Map-Grenzen sind
				if target_x >= 1 and target_x <= GRID_WIDTH and target_y >= 1 and target_y <= GRID_HEIGHT then
					if is_visible then
						-- Zeichne ein spezielles Preview-Tile (z.B. ID 0 oder ein semi-transparentes)
						tilemap.set_tile(tilemap_url, "fog", target_x, target_y, 42)
					else
						-- Stelle den Originalzustand aus der Matrix wieder her
						local original_y = (GRID_HEIGHT + 1) - target_y
						tilemap.set_tile(tilemap_url, "fog", target_x, target_y, self.fog_matrix[original_y][target_x])
					end
				end
			end
		end
	end
end



function on_input(self, action_id, action)
	-- 1. Mausposition immer berechnen
	local mouse_x = math.floor(action.x / TILE_SIZE) + 1
	local mouse_y = math.floor(action.y / TILE_SIZE) + 1
	local mouse_y_inverted = (GRID_HEIGHT + 1) - mouse_y

	-- 2. HOVER EFFEKT (Muss außerhalb von action_id == hash("touch") sein!)
	if not action_id then
		-- Nur aktualisieren, wenn die Maus das Feld gewechselt hat
		if mouse_x ~= self.last_mouse_x or mouse_y_inverted ~= self.last_mouse_y then
			-- Alte Vorschau an der alten Position löschen
			if self.last_mouse_x then
				draw_brick_preview(self, self.last_mouse_x, self.last_mouse_y, false)
			end

			-- Neue Vorschau an der aktuellen Position zeichnen
			draw_brick_preview(self, mouse_x, mouse_y_inverted, true)

			self.last_mouse_x = mouse_x
			self.last_mouse_y = mouse_y_inverted
		end
	end

	-- 3. KLICK (Platzieren)
	if action_id == hash("touch") and action.pressed then
		print("klick")
		local selected_brick = BRICKS["T"]

		for y = 1, BRICK_SIZE do
			for x = 1, BRICK_SIZE do
				if selected_brick[y][x] == 1 then
					local target_y = y + mouse_y_inverted - 2
					local target_x = x + mouse_x - 2

					-- Sicherheits-Check, damit wir nicht außerhalb der Matrix schreiben
					if target_y >= 1 and target_y <= GRID_HEIGHT and target_x >= 1 and target_x <= GRID_WIDTH then
						self.fog_matrix[target_y][target_x] = 0
					end
				end
			end
		end
		-- Map neu zeichnen (ohne Ground, um Performance zu sparen)
		draw_tilemap(self, false)
	end
end