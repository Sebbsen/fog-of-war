-- Wir definieren die Größe
local GRID_WIDTH = 10
local GRID_HEIGHT = 10

local TILESETS_KEY = {
	[1] = "forest",
	[2] = "mountain",
	[3] = "medow",
	[4] = "pond"
}

local TILESETS = {
	["forest"] = {
		["start"] = 1,
		["end"] = 3 
	},
	["mountain"] = {
		["start"] = 11,
		["end"] = 13 
	},
	["medow"] = {
		["start"] = 21,
		["end"] = 25 
	},
	["pond"] = {
		["start"] = 31,
		["end"] = 33 
	},
	["fog"] = {
		["start"] = 101,
		["end"] = 200 
	}
}

local TILE_SIZE = 64

local BRICK_SIZE = 3
local BRICKS = {
	["L"] = {
		{0, 1, 0},
		{0, 1, 0},
		{0, 1, 1}
	},
	["J"] = {
		{0, 1, 0},
		{0, 1, 0},
		{1, 1, 0}
	},
	["T"] = {
		{0, 0, 0},
		{1, 1, 1},
		{0, 1, 0}
	}
}


-- Das ist unsere Matrix (Zahlen-Tabelle)
local function create_ground_matrix()
	local m = {}
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			-- Wir füllen alles mit der 1 (dein erstes Tile in der Tilesource)
			-- Wenn du ein Schachbrettmuster willst: ((x + y) % 2 == 0) ? 1 : 2
			m[y][x] = math.random(1, 4) 
		end
	end
	return m
end

local function create_fog_matrix()
	local tile_start = TILESETS["fog"]["start"]
	local m = {}
	local i = 0
	for y = 1, GRID_HEIGHT do
		m[y] = {}
		for x = 1, GRID_WIDTH do
			-- Wir füllen alles mit der 1 (dein erstes Tile in der Tilesource)
			-- Wenn du ein Schachbrettmuster willst: ((x + y) % 2 == 0) ? 1 : 2
			m[y][x] = tile_start+i
			i = i+1
		end
	end
	return m
end
	

function init(self)
	-- 1. Matrix generieren
	self.ground_matrix = create_ground_matrix()
	self.fog_matrix = create_fog_matrix()

	msg.post(".", "acquire_input_focus")
	
	draw_tilemap(self, true)
end

function getRandomGroundTileOfType(tile_type) 
	-- 1 ist forest 2 ist mountain, 3 ist medow, 4 ist pound
	-- ich will die Zahl 1,2,3,4 dann dazu ein random tile dieser art zurückgeben
	-- mit dem medow.start und medow.end etc

	-- Hole den Namen basierend auf dem Typ (z.B. "forest")
	local set_name = TILESETS_KEY[tile_type]

	-- Sicherheitshalber prüfen, ob der Typ existiert
	if set_name and TILESETS[set_name] then
		local set = TILESETS[set_name]
		-- Gibt eine Zufallszahl zwischen dem Start- und End-Tile zurück
		return math.random(set["start"], set["end"])
	end

	-- Fallback: Falls etwas schief geht, gib Tile 0 oder 1 zurück
	return 1
end

function draw_tilemap(self, draw_ground)
	print("draw")
	-- 2. Pfad zur Tilemap-Komponente definieren
	-- "#level" ist die ID der Tilemap-Komponente im Game Object
	local tilemap_url = "#level" 

	-- 3. Die Matrix auf die Tilemap zeichnen
	for y = 1, GRID_HEIGHT do
		for x = 1, GRID_WIDTH do
			local ground_tile_to_draw = getRandomGroundTileOfType(self.ground_matrix[y][x])
			local fog_tile_to_draw = self.fog_matrix[y][x]
			-- invertieren, damit das erste Tile oben links ist
			local inverted_y = (GRID_HEIGHT + 1) - y

			-- Syntax: tilemap.set_tile(url, layer_name, x, y, tile_id)
			if draw_ground then
				tilemap.set_tile(tilemap_url, "ground", x, inverted_y, ground_tile_to_draw)
			end
			tilemap.set_tile(tilemap_url, "fog", x, inverted_y, fog_tile_to_draw)
		end
	end
end



function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		print("klick")
		local selected_brick = BRICKS["T"]
		local mouse_x = math.floor(action.x / TILE_SIZE) + 1
		local mouse_y = math.floor(action.y / TILE_SIZE) + 1
		--invert y weil matrix auch inverted
		mouse_y_inverted = (GRID_HEIGHT + 1) - mouse_y

		


		for y = 1, BRICK_SIZE do
			for x = 1, BRICK_SIZE do
				if selected_brick[y][x] == 1 then
					self.fog_matrix[y+mouse_y_inverted-2][x+mouse_x-2] = 0;
				end
			end
		end
		draw_tilemap(self, false)
	end
	
end